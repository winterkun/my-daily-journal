滴滴面，压力巨大，问得问题巨细，估计是挂了，后面面试官也给了我很多建议：

制定脚手架迁移升级技术方案，实现webpack4升级至rsbuild，解决配置文件转换问题、依赖兼容问题、代码
兼容问题；实现项目构建 10s+ 压缩至 1s（热更新速度提升 90%）
面试官：rspack为什么可以实现这么快的构建速度
只回答出一个rust语言特性+多线程并行

ai回答：
Rspack（Rsbuild 的底层引擎）的速度优势源于以下核心技术：
Rust 内核：语言级性能碾压
Rspack 核心模块（依赖解析、AST 处理、代码生成）用 Rust 编写，相比 Webpack 的 JavaScript 实现，执行效率提升 5-10 倍（尤其在处理大量模块解析、AST 转换等计算密集型任务时）。
优化的依赖图分析
采用增量依赖图：首次构建生成完整依赖图，后续更新仅重新计算变更模块的依赖链（Webpack4 需重新遍历全量依赖图）；
并行化依赖解析：利用 Rust 的rayon库实现多核并行解析模块，充分利用 CPU 资源（Webpack4 的解析器受限于 JS 单线程，并行能力弱）。
高效缓存机制
多级缓存：支持内存缓存（开发环境）、磁盘缓存（跨会话复用）、远程缓存（团队共享）；
精准缓存失效：基于内容哈希（而非文件时间戳）判断模块是否变更，避免无效缓存失效。
内置优化的工具链
集成swc（Rust 编写的转译工具）：比 babel 快 5-10 倍，同时支持 TS、JSX 转译；
自研压缩器：oxc（Rust 实现）比 Terser 快 20-30 倍，且压缩率相当；
高效 Tree-shaking：基于 Rust 的 AST 分析，更精准地剔除死代码（比 Webpack4 减少 10-15% 的无效代码）。
架构级优化
无插件开销：Webpack 的插件系统基于事件流，存在大量回调和钩子开销；Rspack 采用 “预编译 + 内置优化” 模式，多数功能无需插件即可实现；
减少 IO 操作：通过内存缓存模块内容，避免重复读取磁盘（Webpack4 频繁读写临时文件）。


面试官：你简历里有写threejs，聊一下webgl的绘制原理
没答上来。。。说自己只用了threejs，不太了解webgl

后面ai去了解：
串联起来：从 “铁丝骨架” 到 “屏幕画面” 的全过程
想象你要在电脑上显示一个 3D 立方体：
数据准备：先拿到立方体的 8 个顶点坐标、每个面的颜色；
着色器程序：定好规则（比如 “从正面看，左边的顶点向左移一点”“红色面在光照下更亮”）；
顶点处理：按规则调整 8 个顶点的位置，确定它们在画面中的最终坐标；
图元装配：用线把顶点连起来，形成 6 个面（每个面拆成 2 个三角形，共 12 个三角形）；
光栅化：把这 12 个三角形 “拍扁” 成屏幕上的像素点，每个三角形对应一片像素；
最后（片元处理）：按规则给这些像素上色（比如红色面的像素涂红，边缘像素稍微调暗），就成了我们看到的画面。
这样再看这些命名，是不是就清晰了？每个名字都对应着它的核心动作：
数据准备：准备数据；
着色器程序：制定处理规则；
顶点处理：处理顶点；
图元装配：组装基本图形；
光栅化：映射到像素网格。
本质上，这些步骤就是计算机把 “3D 的骨架” 一步步 “翻译” 成 “2D 的像素画面” 的过程～

面试官：你简历里有写到cdn加速，可以说说吗
又没答上来，滴滴面压力太大了，只能说自己就是在常见的依赖库比如vue使用了cdn加速，估计还是没让面试官满意

ai：
Vue 项目中会引入大量第三方库（如 Vue 本身、路由、状态管理库等），这些库体积固定、更新频率低，非常适合用 CDN 加载。
常见需配置的库：
Vue 生态核心库：vue、vue-router、vuex（或 Pinia）
通用工具库：axios（请求库）、lodash（工具函数）、moment.js/day.js（日期处理）
UI 组件库：element-ui、ant-design-vue、vant 等
其他库：echarts（图表）、three.js（3D 渲染）、vue-i18n（国际化）等
为什么要配置这些？
减小打包体积：第三方库（如 Vue、element-ui）通常占打包体积的 30% 以上，用 CDN 加载后，dist 文件夹体积可显著减小（比如从 2MB 降到 500KB），加快构建和部署速度。
利用浏览器缓存：CDN 上的第三方库通常有稳定的版本号（如 vue@2.6.14），用户访问其他网站时若已缓存过该版本，可直接复用，无需重新下载。
加速加载：CDN 节点分布式部署，用户会从最近的节点拉取资源（比如北京用户加载上海 CDN 节点的 Vue 库），比从本地服务器加载更快。

配置示例（以 Vue CLI 项目为例）
在 public/index.html 中引入 CDN 链接：
<!-- 引入 Vue 核心库 -->
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js"></script>
<!-- 引入 Vue Router -->
<script src="https://cdn.jsdelivr.net/npm/vue-router@3.5.3/dist/vue-router.min.js"></script>
<!-- 引入 Element UI 样式和脚本 -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/element-ui@2.15.13/lib/theme-chalk/index.css">
<script src="https://cdn.jsdelivr.net/npm/element-ui@2.15.13/lib/index.js"></script>
在 vue.config.js 中配置 “排除打包”（告诉 Webpack 不需要把这些库打包进 dist）：
module.exports = {
  configureWebpack: {
    externals: {
      // 键：项目中 import 的名称；值：CDN 暴露的全局变量名
      'vue': 'Vue',
      'vue-router': 'VueRouter',
      'element-ui': 'ELEMENT'
    }
  }
}

注意事项
版本锁定：CDN 链接需指定具体版本（如 vue@2.6.14），避免因自动升级导致兼容性问题。
优先级：CDN 资源加载失败时，可配置本地备份（如通过 onerror 切换到本地资源）。
小型项目谨慎用：若项目依赖少、体积小，CDN 带来的收益可能低于多域名请求的开销（浏览器对同一域名并发请求有限制，但 CDN 通常用独立域名，需权衡）。
通过以上配置，Vue 项目能充分利用 CDN 优势，优化加载性能。




之前另外一个面试官关于我的直播这一块的问题：
面试官：你简历里有写  实现 “直播延迟 <2s” 和 “点播秒开率 99%”

这个我圆不回来，这个指标是我夸大的成分在里面，然后后面我去查对应的技术方案，如何做到直播延迟小于2s，了解到了ll-hls这个技术
“基于 LL-HLS 协议优化：后端将分片目标时长设为 2s，同时通过部分片段（Partial Segment）机制，生成 1s 内容后立即传输；前端通过 Hls.js 配置动态缓冲策略（maxBufferLength=2s，实际启动缓冲 0.7s），配合 CDN 边缘节点传输（耗时 0.3s），最终在主流浏览器及良好网络下实现总延迟 < 2s。”
核心逻辑：用 LL-HLS 的 “部分片段传输” 打破 “完整分片生成时间” 的限制，用 “缓冲上限≠实际缓冲量” 解释缓冲参数的实际作用，再叠加传输优化，就能把总延迟压缩到 2s 内 —— 不是 “硬凑数字”，而是协议特性和工程优化的必然结果。


第三位面试官：
问了webpack生命周期，url输入到页面渲染发生了什么，vue23的响应式原理，项目里遇到的最难的问题，webpack和vite和rspack的区别。主要是这几个问题吧